#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <math.h>

int main() {
	char A[16];
	char B[16];
	int C[16];

	int item;

	short int siz = 0;
	short int sum = 0;

	memset(B, 0, sizeof(B));
	memset(C, 0, sizeof(C));

	for (int i = 0; i < 16; ++i) {
		while (1) {
			printf("Enter number #%d: ", i);
			scanf_s("%d", &item);
			if (abs(item) <= CHAR_MAX) {
				A[i] = item;
				break;
			}
			else {
				printf("Value out of range! Try again\n\n");
			}
		}
	}
	
	_asm {
		lea esi, A;				// загрузить исполнительный адрес массива A
		lea edi, B;				// загрузить исполнительный адрес массива B
		lea ebx, C;				// загрузить исполнительный адрес массива C

		mov ecx, 16;			// установить счётчик цикла
		
		mov ax, 0;				// под расширение чисел из массива A
		mov dx, 0;				// под сумму чисел из массива A

	BODY: cmp byte ptr [esi], -8;		// сравнить элемент массива A с числом -8
		jng NEXT;				// если элемент массива A меньше либо равен -8, то перейти к следующей итерации

		inc ax;				// иначе увеличить значение счётчика
		push ax;				// поместить значение счётчика в стек

		mov al, [esi];			// скопировать значение элемента массива A в регистр al (как байт)

		mov [edi], al;			// поместить в элемент массива B значение подходящего элемента из массива A
		inc edi;				// переместить указатель на следующий элемент массива B

		mov [ebx], esi;			// поместить в элемент массива C адрес подходящего элемента из массива A
		add ebx, 4;				// переместить указатель на следующий элемент массива C

		cbw;					// знаковое расширение до слова
		cmp ax, 0;				// сравнить число в регистре ax с нулём
		jge INCR;				// если в регистре ax число положительно, то перейти к сложению
		neg ax;				// иначе взять модуль числа

	INCR: add dx, ax;				// прибавить к сумме значение регистра ax
		pop ax;				// восстановить значение счётчика из стека

	NEXT: inc esi;				// перейти к следующему элементу массива
		dec ecx;				// уменьшить значение счётчика цикла на 1
		cmp ecx, 0;				// проверить значение счётчика
		jne BODY;				// если не 0, то перейти к следующей итерации
		nop;					// иначе закончить работу цикла

		mov sum, dx;			// поместить в переменную sum значение суммы модулей подходящих чисел
		mov siz, ax;			// поместить в переменную siz 
	}

	printf("________________________________________________________________________");
	printf("\n|   \t| Array A: \t|\t Array B: \t|\t Array C:\t|\n");
	printf("|_______|_______________|_______________________|_______________________|\n");
	for (int i = 0; i < sizeof(A) / sizeof(short int); ++i) {
		printf("| %d. \t|\t%d", i, A[i]);
		if (i < siz) {
			printf("\t|\t\t%d\t|\t%x\t\t|\n", B[i], C[i]);
		}
		else {
			printf("\t| \t\t\t|\t\t\t|\n");
		}
	}
	printf("|_______|_______________|_______________________|_______________________|\n");

	printf("\n\nSum: %d\nSize: %d\n\n", sum, siz);

	return 0;
}
