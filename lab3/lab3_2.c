#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <math.h>

int main() {
	short int A[16];
	short int B[16];
	int C[16];

	int item;

	short int siz = 0;
	int sum = 0;

	memset(B, 0, sizeof(B));
	memset(C, 0, sizeof(C));

	for (int i = 0; i < 16; ++i) {
		while (1) {
			printf("Enter number #%d: ", i);
			scanf_s("%d", &item);
			if (abs(item) <= SHRT_MAX) {
				A[i] = item;
				break;
			}
			else {
				printf("Value out of range! Try again\n\n");
			}
		}
	}
	
	_asm {
		lea esi, A;			// загрузить исполнительный адрес массива A
		lea edi, B;			// загрузить исполнительный адрес массива B
		lea ebx, C;			// загрузить исполнительный адрес массива C

		mov ecx, 16;		// установить счётчик цикла
		
		mov eax, 0;			// под расширение чисел из массива A
		mov edx, 0;			// под сумму чисел из массива A

	BODY: cmp word ptr [esi], -8;	// сравнить элемент массива A с числом -8
		jng NEXT;			// если элемент массива A меньше либо равен -8, то перейти к следующей итерации

		inc ax;			// иначе увеличить значение счётчика
		push ax;			// поместить значение счётчика в стек

		mov ax, [esi];		// скопировать значение элемента массива A в регистр ax (как слово)

		mov [edi], ax;		// поместить в элемент массива B значение подходящего элемента из массива A
		add edi, 2;			// переместить указатель на следующий элемент массива B

		mov [ebx], esi;		// поместить в элемент массива C адрес подходящего элемента из массива A
		add ebx, 4;			// переместить указатель на следующий элемент массива C

		cwde;				// знаковое расширение до двойного слова в eax
		cmp eax, 0;			// сравнить число в регистре eax с нулём
		jge INCR;			// если в регистре eax число положительно, то перейти к сложению
		neg eax;			// иначе взять модуль числа

	INCR: add edx, eax;		// прибавить к сумме значение регистра eax
		pop ax;			// восстановить значение счётчика из стека

	NEXT: add esi, 2;			// перейти к следующему элементу массива
		dec ecx;			// уменьшить значение счётчика цикла на 1
		cmp ecx, 0;			// проверить значение счётчика
		jne BODY;			// если не 0, то перейти к следующей итерации
		nop;				// иначе закончить работу цикла

		mov sum, edx;		// поместить в переменную sum значение суммы модулей подходящих чисел
		mov siz, ax;		// поместить в переменную siz 
	}

	printf("________________________________________________________________________");
	printf("\n|   \t| Array A: \t|\t Array B: \t|\t Array C:\t|\n");
	printf("|_______|_______________|_______________________|_______________________|\n");
	for (int i = 0; i < sizeof(A) / sizeof(short int); ++i) {
		printf("| %d. \t|\t%d", i, A[i]);
		if (i < siz) {
			printf("\t|\t\t%d\t|\t%x\t\t|\n", B[i], C[i]);
		}
		else {
			printf("\t| \t\t\t|\t\t\t|\n");
		}
	}
	printf("|_______|_______________|_______________________|_______________________|\n");

	printf("\n\nSum: %d\nSize: %d\n\n", sum, siz);

	return 0;
}
