#include <stdio.h>


void bin(int k, int size) {
    for(int i = size * 8; i > 0; --i) {
        printf("%d", (k & (1 << (i - 1))) ? 1 : 0);
    }
}


int main() {
    //char A[6] = {-57, -22, -106, -73, -127, -37};
    char sample = 3;
    short int A[6] = {-7325, -6730, -20782, -19609, -27223, -261};
    char isWord = 0;
    int size = 0;
    int volume = 0;

    if(sizeof(A[0]) == sizeof(short int)) {
        isWord = 1;
        size = sizeof(short int);
        volume = sizeof(A) / size;
    } else {
        size = sizeof(char);
        volume = sizeof(A) / size;
    }


    printf(" _______________________________________________________________________________________");
    printf("\n|   \t|\t Binary representation: \t|\t Heximal representation:\t|\n");
    printf("|_______|_______________________________________|_______________________________________|\n");
    for (int i = 0; i < volume; ++i) {
        printf("|   %d\t|\t", i + 1);
        if (!isWord) {
            printf("\t");
        }
        bin(A[i], size);
        printf("\t\t|\t\t%x\t\t|\n", A[i]);
    }
    printf("|_______|_______________________________________|_______________________________________|\n\n\n");


    _asm {
        lea esi, A;                     //занести адрес массива А в регистр esi
        mov ecx, volume;                //занести в регистр ecx размер массива А

    CONDITION:
        cmp isWord, 1;                  //сравнить значение флага isWord с нулём
        je WORDBODY;                    //если isWord == 1, то перейти к метке WORD
                                        //иначе перейти к обработке массива А как массива байтов
    BYTEBODY:
        mov al, [esi];                  //скопировать в регистр al значение по адресу esi для модификации
        and al, 11000000b;              //обнулить все биты в регистре al кроме двух старших
        shr al, 6;                      //логический сдвиг вправо на 4 значения в регистре al

        mov bl, [esi];                  //скопировать в регистр bl значение по адресу esi для модификации
        and bl, 00000011b;              //обнулить все биты в регистре bl кроме двух младших

        mov dl, [esi];                  //скопировать в регистр dl значение по адресу esi для модификации

        cmp al, bl;                     //сравнить, совпадают ли значения в регистрах al и bl
        jne NEXT;                       //если не совпадают, то перейти к следующей итерации

        cmp al, sample;                 //иначе сравнить значение регистра al с образцом sample
        jne NEXT;                       //если не совпадают, то перейти к следующей итерации
        
        or dl, 00011000b;               //иначе установить битовое поле 4:3

        mov [esi], dl;                  //поместить обработанный элмемент в массив A
        inc esi;                        //переместить указатель на следующий элемент массива A
        jmp NEXT;                       //перейти к следующей итерации

    WORDBODY:
        mov ax, [esi];                  //скопировать в регистр ax значение по адресу esi для модификации
        and ax, 1100000000000000b;      //обнулить все биты в регистре ax кроме двух старших
        shr ax, 14;                     //логический сдвиг вправо на 16 значения в регистре ax

        mov bx, [esi];                  //скопировать в регистр bx значение по адресу esi для модификации
        and bx, 0000000000000011b;      //обнулить все биты в регистре bx кроме двух младших

        mov dx, [esi];                  //скопировать в регистр dx значение по адресу esi для модификации

        cmp ax, bx;                     //сравнить, совпадают ли значения в регистрах ax и bx
        jne NEXT;                       //если не совпадают, то перейти к следующей итерации

        cmp bl, sample;                 //иначе сравнить значение регистра ax с образцом sample
        jne NEXT;                       //если не совпадают, то перейти к следующей итерации

        or dx, 0000000000011000b;       //иначе установить битовое поле 4:3 в регистре dx

        mov [esi], dx;                  //поместить обработанный элмемент в массив A
        add esi, 2;                     //переместить указатель на следующий элемент массива A
        jmp NEXT;                       //перейти к следующей итерации

    NEXT:
        dec ecx;                        //уменьшить значение счётчика на 1
        cmp ecx, 0;                     //сравнить значение счётчика с нулём
        jne CONDITION;                  //если оно не равно 0, то перейти обработке массива
        nop;

    }

    printf(" _______________________________________________________________________________________");
    printf("\n|   \t|\t Binary representation: \t|\t Heximal representation:\t|\n");
    printf("|_______|_______________________________________|_______________________________________|\n");
    for (int i = 0; i < volume; ++i) {
        printf("|   %d\t|\t", i + 1);
        if(!isWord) {
            printf("\t");
        }
        bin(A[i], size);
        printf("\t\t|\t\t%x\t\t|\n", A[i]);
    }
    printf("|_______|_______________________________________|_______________________________________|\n\n\n");

    return 0;
}
